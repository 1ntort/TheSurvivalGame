using script reflection

function TheSurvivalGame_applyNBT(item: text = "barrier", name: text = "none", nbt: text = "{}", static: boolean = false, right click event: text = "none", left click event: text = "none", ui event: text = "none") :: item:
    set {_base item} to {_item} parsed as item
    set {_nbt item} to {_base item} with nbt from {_nbt} # @skignore
    if {_name} is "none":
        return {_nbt item}
    
    set string tag "name" of custom nbt of {_nbt item} to {_name} # @skignore
    set boolean tag "static" of custom nbt of {_nbt item} to {_static} # @skignore
    set string tag "left_click_event" of custom nbt of {_nbt item} to {_left click event} # @skignore
    set string tag "right_click_event" of custom nbt of {_nbt item} to {_right click event} # @skignore
    set string tag "ui_event" of custom nbt of {_nbt item} to {_ui event} # @skignore
    
    set item flags of {_nbt item} to hide unbreakable and hide attributes
    return {_nbt item}

expression:
    patterns:
        [(the|a)] (tsg|the[ ]survival[ ]game) item [(named|with name|called)] %string%
        [(the|a)] (tsg|the[ ]survival[ ]game) item [(named|with name|called)] %string% (with arg[ument][s]|using) %objects%
    return type: item
    parse:
        continue
    get:
        set {_item name} to expr-1
        if (matched pattern) is 1:
            set {_item} to {-TheSurvivalGame items::%{_item name}%}
            if {_item} is set:
                return {_item}
            else:
                return {-TheSurvivalGame items::unknown}
        else if (matched pattern) is 2:
            set {_item function} to the function named "TheSurvivalGame_generateItem_%{_item name}%"
            set {_arguments::*} to exprs-2
            if {_arguments::1} is set:
                if {_arguments::2} is set:
                    if {_arguments::3} is set:
                        set {_item} to the result of {_item function} with arguments {_arguments::1}, {_arguments::2} and {_arguments::3}
                    else:
                        set {_item} to the result of {_item function} with arguments {_arguments::1} and {_arguments::2}
                else:
                    set {_item} to the result of {_item function} with arguments {_arguments::1}
                    
            if {_item} is set:
                return {_item}
            else:
                return {-TheSurvivalGame items::unknown}
    set:
        set {_item name} to expr-1
        set {-TheSurvivalGame items::%{_item name}%} to the change value
    remove:
        set {_item name} to expr-1
        delete {-TheSurvivalGame items::%{_item name}%}

expression:
    patterns:
        [the] (tsg|the[ ]survival[ ]game) current (ui|gui|inventory) of %player%
        [the] (tsg|the[ ]survival[ ]game) back (ui|gui|inventory) of %player%
        [the] (tsg|the[ ]survival[ ]game) current and back (ui|gui|inventory) of %player%
    return type: strings
    parse:
        continue
    get:
        set {_player} to expr-1
        set {_uuid} to {_player}'s uuid
        set {_current UI} to {-TheSurvivalGame player data temp::%{_uuid}%::current UI}
        set {_back UI} to {-TheSurvivalGame player data temp::%{_uuid}%::back UI}
        
        if (matched pattern) is 1:
            return {_current UI}
        else if (matched pattern) is 2:
            return {_back UI}
        else if (matched pattern) is 3:
            return {_current UI} and {_back UI}
    set:
        set {_player} to expr-1
        set {_uuid} to {_player}'s uuid
        set {_changing::*} to the change values
        if (matched pattern) is 1:
            set {-TheSurvivalGame player data temp::%{_uuid}%::current UI} to {_changing::1}
        else if (matched pattern) is 2:
            set {-TheSurvivalGame player data temp::%{_uuid}%::back UI} to {_changing::1}
        else if (matched pattern) is 3:
            set {-TheSurvivalGame player data temp::%{_uuid}%::current UI} to {_changing::1}
            set {-TheSurvivalGame player data temp::%{_uuid}%::back UI} to {_changing::2}
    delete:
        set {_player} to expr-1
        set {_uuid} to {_player}'s uuid
        if (matched pattern) is 1:
            set {-TheSurvivalGame player data temp::%{_uuid}%::current UI} to "none"
        else if (matched pattern) is 2:
            set {-TheSurvivalGame player data temp::%{_uuid}%::back UI} to "none"
        else if (matched pattern) is 3:
            set {-TheSurvivalGame player data temp::%{_uuid}%::current UI} to "none"
            set {-TheSurvivalGame player data temp::%{_uuid}%::back UI} to "none"
    reset:
        set {_player} to expr-1
        set {_uuid} to {_player}'s uuid
        if (matched pattern) is 1:
            set {-TheSurvivalGame player data temp::%{_uuid}%::current UI} to "none"
        else if (matched pattern) is 2:
            set {-TheSurvivalGame player data temp::%{_uuid}%::back UI} to "none"
        else if (matched pattern) is 3:
            set {-TheSurvivalGame player data temp::%{_uuid}%::current UI} to "none"
            set {-TheSurvivalGame player data temp::%{_uuid}%::back UI} to "none"

effect:
    patterns:
        (open|show) [the] (tsg|the[ ]survival[ ]game) [ui|gui|inventory] [(named|with name|called)] %string% (to|for) %player%
        (open|show) [the] (tsg|the[ ]survival[ ]game) [ui|gui|inventory] [(named|with name|called)] %string% (to|for) %player% (with arg[ument][s]|using) %objects%
    parse:
        continue
    trigger:
        set {_ui} to expr-1
        set {_player} to expr-2
        
        set {_function} to the function named "TheSurvivalGame_openUI_%{_ui}%"
        if (matched pattern) is 1:
            run {_function} with arguments {_player}
        else if (matched pattern) is 2:
            set {_arguments::*} to exprs-3
            if {_arguments::1} is set:
                if {_arguments::2} is set:
                    if {_arguments::3} is set:
                        run {_item function} with arguments {_player}, {_arguments::1}, {_arguments::2} and {_arguments::3}
                    else:
                        run {_item function} with arguments {_player}, {_arguments::1} and {_arguments::2}
                else:
                    run {_item function} with arguments {_player} and {_arguments::1}

brig command /thesurvivalgame:fetchnbt: # @skignore
    permission: op
    description: Fetches the NBT data of the item you are holding. (DEVELOPER)
    usage: /fetchnbt
    trigger:
        set {_nbt} to nbt compound of player's tool # @skignore
        set {_nbt string} to "%{_nbt}%"
        
        set {_component} to text component of "&aClick here to copy the item nbt!"
        set hover event of {_component} to hover event showing "&bClick to Copy to Clipboard"
        set click event of {_component} to click event to copy {_nbt string} to clipboard
        
        send "&f" to player
        send component {_component} to player
        send "&f" to player
        
brig command /thesurvivalgame:fetchskriptnbt: # @skignore
    permission: op
    description: Fetches the NBT data of the item you are holding, with string manipulation so it can be pasted in skript. (DEVELOPER)
    usage: /fetchskriptnbt
    trigger:
        set {_nbt} to nbt compound of player's tool # @skignore
        set {_nbt string} to "%{_nbt}%"
        
        replace every """" in {_nbt string} with """"""
        replace every "%%" in {_nbt string} with "%%%%"
        
        set {_component} to text component of "&aClick here to copy the skript item nbt!"
        set hover event of {_component} to hover event showing "&bClick to Copy to Clipboard"
        set click event of {_component} to click event to copy {_nbt string} to clipboard
        
        send "&f" to player
        send component {_component} to player
        send "&f" to player

brig command /thesurvivalgame:fetchcustomitem: # @skignore
    permission: op
    description: Fetches the NBT data of the item you are holding. (DEVELOPER)
    usage: /fetchcustomitem <item name>
    arguments:
        register greedystring arg named "item name":
            if tsg is developer:
                apply suggestions sorted indexes of {-TheSurvivalGame item NBTs::*} in ascending order
    trigger:
        set {_item} to {-TheSurvivalGame items::%{_item name}%}
        set {_nbt} to {-TheSurvivalGame item NBTs::%{_item name}%}
        if {_item} is set:
            if {_nbt} is set:
                set {_name} to raw name of {_item}
                give player TheSurvivalGame_applyNBT({_name}, "none", {_nbt})
                send "&aYou have been given a custom item: ""%{_item name}%""."
            else:
                give player {_item}
                send "&aItem was found, however NBT was not. Make sure to remove ""minecraft:custom_data"" when copying over NBT data to skripts. (%{_item name}%)" to player
        else:
            if {_nbt} is set:
                give player TheSurvivalGame_applyNBT("barrier", "none", {_nbt})
                send "&aNBT for item was found, however the item wasn't. The NBT is safe to copy over to skripts without errors." to player
            else:
                send "&c""%{_item name}%"" isn't a valid item!"